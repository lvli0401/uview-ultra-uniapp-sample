<template>
	<view class="up-count-down">
		<slot>
			<text class="up-count-down__text">{{ formattedTime }}</text>
		</slot>
	</view>
</template>

<script setup lang="uts">
	import { ref, onMounted, onBeforeUnmount, watch } from 'vue'
	import defProps from '../../libs/config/props.uts'
	import { isSameSecond, parseFormat, parseTimeData } from './utils.uts';

	// props
	const props = defineProps({
		// 倒计时时长，单位ms
		time: {
			type: [String, Number],
			default: defProps.getNumber('countDown.time')
		},
		// 时间格式，DD-日，HH-时，mm-分，ss-秒，SSS-毫秒
		format: {
			type: String,
			default: defProps.getString('countDown.format')
		},
		// 是否自动开始倒计时
		autoStart: {
			type: Boolean,
			default: defProps.getBoolean('countDown.autoStart')
		},
		// 是否展示毫秒倒计时
		millisecond: {
			type: Boolean,
			default: defProps.getBoolean('countDown.millisecond')
		}
	})

	// 定义事件
	const emit = defineEmits<{
		(e: 'finish'): void
		(e: 'change', value: any): void
		(e: 'start'): void
		(e: 'pause'): void
		(e: 'reset'): void
	}>()

	// 响应式数据
	const timer = ref(-1)
	const timeData = ref(parseTimeData(0))
	const formattedTime = ref('0')
	const running = ref(false)
	const endTime = ref(0)
	const remainTime = ref(0)

	// 清空定时器
	const clearTimeoutFn = () => {
		if (timer.value !== -1) {
			clearTimeout(timer.value)
		}
		timer.value = -1
	}

	// 获取剩余的时间
	const getRemainTime = (): number => {
		// 取最大值，防止出现小于0的剩余时间值
		return Math.max(endTime.value - Date.now(), 0)
	}
	
	// 暂停倒计时
	const pause = () => {
		running.value = false
		clearTimeoutFn()
		emit('pause')
	}
	
	// 设置剩余的时间
	const setRemainTime = (remain: number) => {
		remainTime.value = remain
		// 根据剩余的毫秒时间，得出该有天，小时，分钟等的值，返回一个对象
		const timeDataValue = parseTimeData(remain)
		timeData.value = timeDataValue
		emit('change', timeDataValue)
		// 得出格式化后的时间
		formattedTime.value = parseFormat(props.format, timeDataValue)
		// 如果时间已到，停止倒计时
		if (remain <= 0) {
			pause()
			emit('finish')
		}
	}

	// 不能定义为函数表达式和箭头函数，否则app-android无法递归调用。
	function macroTick() {
		clearTimeoutFn()
		// 每隔一定时间，更新一遍定时器的值
		// 同时此定时器的作用也能带来毫秒级的更新
		timer.value = setTimeout(() => {
			// 获取剩余时间
			const remain = getRemainTime()
			// 重设剩余时间
			if (!isSameSecond(remain, remainTime.value) || remain == 0) {
				setRemainTime(remain)
			}
			// 如果剩余时间不为0，则继续检查更新倒计时
			if (remainTime.value != 0) {
				macroTick()
			}
		}, 30)
	}

	// 不能定义为函数表达式和箭头函数，否则app-android无法递归调用。
	function microTick() {
		clearTimeoutFn()
		timer.value = setTimeout(() => {
			setRemainTime(getRemainTime())
			if (remainTime.value !== 0) {
				microTick()
			}
		}, 50)
	}
	
	// 根据是否展示毫秒，执行不同操作函数
	const toTick = () => {
		if (props.millisecond) {
			microTick()
		} else {
			macroTick()
		}
	}
	
	// 开始倒计时
	const start = () => {
		if (running.value) return
		running.value = true
		endTime.value = Date.now() + remainTime.value
		toTick()
		emit('start')
	}
	
	// 重置倒计时
	const reset = () => {
		pause()
		remainTime.value = props.time as number
		setRemainTime(remainTime.value)
		if (props.autoStart) {
			start()
		}
		emit('reset')
	}
	
	// 初始化
	const init = () => {
		reset()
	}

	onMounted(() => {
		init()
	})

	// 监听time变化
	watch((): string|number => props.time, (newVal: string|number) => {
		reset()
	})
	
	// 组件卸载前清理定时器
	onBeforeUnmount(() => {
		clearTimeoutFn()
	})

	// 导出供模板使用的方法
	defineExpose({
		start,
		pause,
		reset
	})
</script>

<style
	lang="scss"
	scoped
>
	@import "../../libs/css/components.scss";
	$up-count-down-text-color:$up-content-color !default;
	$up-count-down-text-font-size:15px !default;
	$up-count-down-text-line-height:22px !default;

	.up-count-down {
		&__text {
			color: $up-count-down-text-color;
			font-size: $up-count-down-text-font-size;
			line-height: $up-count-down-text-line-height;
		}
	}
</style>