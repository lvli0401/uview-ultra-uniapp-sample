<template>
	<view
		class="up-notice"
		@tap="clickHandler"
	>
		<slot name="icon">
			<view
				class="up-notice__left-icon"
				v-if="icon"
			>
				<up-icon
					:name="icon"
					:color="color"
					size="19"
				></up-icon>
			</view>
		</slot>
		<view
			class="up-notice__content"
			ref="up-notice__content"
		>
			<view
				ref="up-notice__content__text"
				class="up-notice__content__text"
				:style="[animationStyle]"
			>
				<text
					v-for="(item, index) in innerText"
					:key="index"
					:style="[textStyle]"
				>{{item}}</text>
			</view>
		</view>
		<view
			class="up-notice__right-icon"
			v-if="['link', 'closable'].includes(mode)"
		>
			<up-icon
				v-if="mode === 'link'"
				name="arrow-right"
				:size="17"
				:color="color"
			></up-icon>
			<up-icon
				v-if="mode === 'closable'"
				@click="close"
				name="close"
				:size="16"
				:color="color"
			></up-icon>
		</view>
	</view>
</template>

<script setup lang="uts">
	import { ref, computed, watch, onMounted, onBeforeUnmount, getCurrentInstance } from 'vue'
	import type { PropType } from 'vue'
	import defProps from './rowNotice.uts'
	import { addUnit, error, sleep, getPx, upGetRect } from '../../libs/function/index'
	import { string as testString } from '../../libs/function/test'
	
	const props = defineProps({
		text: {
			type: String,
			default: defProps.getString('rowNotice.text')
		},
		icon: {
			type: String,
			default: defProps.getString('rowNotice.icon')
		},
		mode: {
			type: String,
			default: defProps.getString('rowNotice.mode')
		},
		color: {
			type: String,
			default: defProps.getString('rowNotice.color')
		},
		bgColor: {
			type: String,
			default: defProps.getString('rowNotice.bgColor')
		},
		fontSize: {
			type: [String, Number],
			default: defProps.getNumber('rowNotice.fontSize')
		},
		speed: {
			type: [String, Number],
			default: defProps.getNumber('rowNotice.speed')
		}
	})
	
	const instance = getCurrentInstance()?.proxy!
	const transform = ref('')
	const animationFrameId = ref(0)       // requestAnimationFrame 的 ID
	const startTime = ref(0)              // 动画开始时间
	const currentPosition = ref(0)        // 当前滚动位置
	const scrollWidth = ref(0)            // 文本宽度
	const containerWidth = ref(0)         // 容器宽度
	const isAnimating = ref(false)        // 是否正在动画中
	const show = ref(true)
	const webviewHide = ref(false)        // 页面是否隐藏
	const emit =defineEmits(['click', 'close'])
	
	// 文字内容的样式
	const textStyle = computed(() => {
		let style = {}
		style['whiteSpace'] = 'nowrap !important'
		style['color'] = props.color
		style['fontSize'] = addUnit(props.fontSize)
		return style
	})
	
	// 动画样式
	const animationStyle = computed(() => {
		let style = {}
		style['transform'] = transform.value
		// 使用 requestAnimationFrame 进行动画，不需要 transition 或 animation 相关样式
		return style
	})
	
	// 内部对用户传入的数据进一步分割，放到多个text标签循环，否则如果用户传入的字符串很长（100个字符以上）
	// 放在一个text标签中进行滚动，在低端安卓机上，动画可能会出现抖动现象，需要分割到多个text中可解决此问题
	const innerText = computed(() => {
		let result: string[] = [],
			// 每组text标签的字符长度
			len = 20
		// @ts-ignore
		const textArr = props.text.split('')
		for (let i = 0; i < textArr.length; i += len) {
			// 对拆分的后的text进行slice分割，得到的为数组再进行join拼接为字符串
			result.push(textArr.slice(i, i + len).join(''))
		}
		return result
	})
	
	// 点击通告栏
	const clickHandler = (index: number) => {
		emit('click')
	}
	
	// 点击右侧按钮，需要判断点击的是关闭图标还是箭头图标
	const close = () => {
		emit('close')
	}

	// 动画循环函数(不能定义为函数表达式和箭头函数，否则无法递归调用)
	function animate(timestamp: number) {
		if (!isAnimating.value) return;
		
		if (startTime.value == 0) startTime.value = timestamp;
		
		// 计算经过的时间
		const elapsed = timestamp - startTime.value;
		
		// 根据速度计算移动距离（speed 是每秒移动的像素数）
		const speedNum = parseInt(getPx(props.speed))
		const distance = (speedNum * elapsed) / 1000;
		
		// 更新当前位置
		currentPosition.value = containerWidth.value - distance;
		
		// 当文本完全滚出左侧时，重置到右侧
		if (currentPosition.value <= -scrollWidth.value) {
			startTime.value = timestamp;  // 重置起始时间
			currentPosition.value = containerWidth.value;
		}
		
		// 应用变换
		transform.value = `translateX(${currentPosition.value}px)`;
		
		// 继续下一帧动画
		animationFrameId.value = requestAnimationFrame((ts) => animate(ts));
	}
	
	// 初始化并开始滚动
	const startScroll = async () => {
		// 如果已在动画中，先停止
		if (animationFrameId.value > 0) {
			cancelAnimationFrame(animationFrameId.value);
			animationFrameId.value = 0;
		}
		
		// 获取容器和文字的宽度
		// @ts-ignore
		await sleep(10); // 短暂延迟确保DOM渲染完成
		// @ts-ignore
		const textRect = await upGetRect('.up-notice__content__text', false, instance) as NodeInfo;
		// @ts-ignore
		const containerRect = await upGetRect('.up-notice__content', false, instance) as NodeInfo;
		
		scrollWidth.value = textRect.width ?? 0;
		containerWidth.value = containerRect.width ?? 0;
		
		// 设置初始位置在容器右侧外
		currentPosition.value = containerWidth.value;
		startTime.value = 0;
		isAnimating.value = true;
		
		// 开始动画循环
		animate(0);
	}
	
	// 停止滚动动画
	const stopScroll = () => {
		isAnimating.value = false;
		if (animationFrameId.value > 0) {
			cancelAnimationFrame(animationFrameId.value);
			animationFrameId.value = 0;
		}
	}
	
	watch(():string => props.text, (newValue: string) => {
		// #ifndef APP-NVUE
		startScroll();
		// #endif
		
		if(!testString(newValue)) {
			error('noticebar组件direction为row时，要求text参数为字符串形式')
		}
	}, {immediate: true})
	
	watch((): string|number => props.fontSize, () => {
		// #ifndef APP-NVUE
		startScroll();
		// #endif
	})
	
	watch((): string|number => props.speed, () => {
		// #ifndef APP-NVUE
		startScroll();
		// #endif
	})
	
	onMounted(() => {
		// #ifdef APP-PLUS
		// 在APP上(含nvue)，监听当前webview是否处于隐藏状态(进入下一页时即为hide状态)
		// 如果webivew隐藏了，为了节省性能的损耗，应停止动画的执行，同时也是为了保持进入下一页返回后，滚动位置保持不变
		var pages = getCurrentPages()
		var page = pages[pages.length - 1]
		var currentWebview = page.$getAppWebview()
		currentWebview.addEventListener('hide', () => {
			webviewHide.value = true
			stopScroll(); // 页面隐藏时停止动画
		})
		currentWebview.addEventListener('show', () => {
			webviewHide.value = false
			startScroll(); // 页面显示时恢复动画
		})
		// #endif

		// #ifndef APP-NVUE
		startScroll();
		// #endif

		if(!testString(props.text)) {
			error('noticebar组件direction为row时，要求text参数为字符串形式')
		}
	})
	
	onBeforeUnmount(() => {
		stopScroll(); // 组件销毁前清理动画
	})
</script>

<style lang="scss" scoped>
	@import "../../libs/css/components.scss";
	.up-notice {
		@include flex;
		align-items: center;
		justify-content: space-between;

		&__left-icon {
			align-items: center;
			margin-right: 5px;
		}

		&__right-icon {
			margin-left: 5px;
			align-items: center;
		}

		&__content {
			text-align: right;
			flex: 1;
			@include flex;
			flex-wrap: nowrap;
			overflow: hidden;

			&__text {
				font-size: 14px;
				color: $up-warning;
				/* #ifndef APP-NVUE */
				// 这一句很重要，为了能让滚动左右连接起来
				// word-break: keep-all;
				white-space: nowrap;
				/* #endif */
				@include flex(row);
				line-height: 1;
			}
		}

	}
</style>